#include "散列表_unicode切片_编码.h"

#define 容量表表项 28
static uint32_t 容量质数表[容量表表项] = { //采用小于 2^n 的最大质数，构成容量质数表
    31, 61, 127,
    251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521,
    131071, 262139, 524287, 1048573, 2097143, 4194301, 8388593, 16777213,
    33554393, 67108859, 134217689, 268435399, 536870909, 1073741789, 2147483647, 4294967291
};
/******************************************************************************
 * 创建一个 空散列表 ，初始化后返回 散列表结构体的指针
 * 期望容量：期望的最小容量，如果为0则使用容量表最小容量
 *****************************************************************************/
散列表 * 创建散列表(uint32_t 期望容量) {
    // 查找容量质数表，确定新散列表容量
    int 实际容量;
    int i=0; // 从头到尾遍历容量表，直到找到足够容纳“期望容量”的最小质数
    while (容量质数表[i] < 期望容量) {
        i++;
    }
    实际容量 = 容量质数表[i];
    // 申请堆内存 散列表对象
    散列表* 散列表指针 = (散列表*)malloc(sizeof(散列表)+实际容量*sizeof(散列表链表节点*));
    // 初始化散列表
    散列表指针->用量 = 0;
    散列表指针->容量 = 实际容量;
    for (int i=0; i<实际容量; i++) {// 初始化 数据区，节点指针数组全部置为 空 NULL
        散列表指针->节点指针数组[i] = NULL;
    }
    return 散列表指针;
}
// 创建 散列表链表节点
散列表链表节点 * 创建散列表链表节点(unicode切片 键, 单词类型 值) {
    // 构造新节点
    散列表链表节点 * 新节点指针 = (散列表链表节点*)malloc(sizeof(散列表链表节点));
    新节点指针->键 = 键; //初始化数据域
    新节点指针->值 = 值;
    新节点指针->下一节点指针 = NULL;
    return 新节点指针;
}
/******************************************************************************
 * 释放整个散列表，包括节点数组和链表节点，以及节点下游相关数据区
 * 散列表：被释放的散列表结构体 的 指针
 *****************************************************************************/
void 散列表_释放(散列表* 散列表指针) {
    // 遍历 节点指针数组，逐个释放链表
    for (int i=0; i<(散列表指针->容量); i++) {
        if (散列表指针->节点指针数组[i] != NULL) { //数组中的节点指针不为空，就释放
            散列表_节点链表_释放(散列表指针->节点指针数组[i]);
        }
    }
    free(散列表指针); // 释放 散列表结构体
}
// 提供指向首节点的指针，释放整个单向链表的所有节点
void 散列表_节点链表_释放(散列表链表节点* 首节点指针) {
    散列表链表节点* 当前节点指针=首节点指针;
    散列表链表节点* 上一节点指针;
    // 遍历单向链表，释放上一节点
    while (当前节点指针->下一节点指针 != NULL) {
        上一节点指针 = 当前节点指针;
        当前节点指针 = 当前节点指针->下一节点指针;
        // 释放上一节点
        unicode切片_清空(&(上一节点指针->键)); // 先清空 切片 数据区
        free(上一节点指针); //再释放节点
    }
    // 释放尾节点
    unicode切片_清空(&(当前节点指针->键)); // 先清空 切片 数据区
    free(当前节点指针);
} 
/******************************************************************************
 * 插入一个 键-值 对，
 * 初始容量：unicode切片数组 初始化分配空间
 *****************************************************************************/
void 散列表_插入(散列表* 散列表指针, unicode切片 键, 单词类型 值) {
    // 检查扩容，大于最大装载因子触发扩容
    if (((散列表指针->用量)+1)/(散列表指针->容量) >= 散列表_最大装载因子) {
        散列表_扩容(散列表指针, 0);
    }
    // 构建 键-值 对节点
    散列表链表节点 * 新节点指针 = 创建散列表链表节点(键, 值);
    // 查询并插入新节点
    uint32_t 键散列值 = unicode切片_计算散列值(&键, 散列表指针->容量);
    if (散列表指针->节点指针数组[键散列值] == NULL) { //如果该 键 不存在
        散列表指针->节点指针数组[键散列值] = 新节点指针;
    } else { //发生 散列碰撞，向链表头部插入新节点
        新节点指针->下一节点指针 = 散列表指针->节点指针数组[键散列值];
        散列表指针->节点指针数组[键散列值] = 新节点指针;
    }
}
/******************************************************************************
 * 扩容散列表到至少可以容纳 期望容量
 * 期望容量：期望容量表扩容后的最小容量。如果为0则自动扩容到容量表下一容量
 *****************************************************************************/
void 散列表_扩容(散列表* 旧散列表指针, uint32_t 期望容量) {
    // 查找容量质数表，确定新散列表容量
    int 新容量;
    if (期望容量 == 0) { 期望容量 = 旧散列表指针->容量 + 1; } //如果为0，则自动扩容到容量表下一项
    int i=0; // 从头到尾遍历容量表，直到找到足够容纳“期望容量”的最小质数
    while (容量质数表[i] < 期望容量) {
        i++;
    }
    新容量 = 容量质数表[i];
    // 申请新容量表空间，并初始化 新散列表
    散列表 * 新散列表指针 = malloc(sizeof(散列表)+新容量*sizeof(散列表链表节点*));
    新散列表指针->容量 = 新容量;
    新散列表指针->用量 = 旧散列表指针->用量;
    for (int i=0; i<容量质数表[0]; i++) {// 初始化 数据区，节点指针数组全部置为 空 NULL
        新散列表指针->节点指针数组[i] = NULL;
    }
    // 遍历旧散列表节点，将各节点填入 新散列表
    散列表链表节点 * 当前节点指针;
    散列表链表节点 * 上一节点指针;
    for (int i=0; i<旧散列表指针->用量; i++) {
        if (旧散列表指针->节点指针数组[i] != NULL) { //处理非空表项
            // 遍历单向链表，将其插入新散列表
            当前节点指针 = 旧散列表指针->节点指针数组[i];
            while(当前节点指针->下一节点指针 != NULL){
                上一节点指针 = 当前节点指针;
                当前节点指针 = 当前节点指针->下一节点指针;
                散列表_不扩容插入节点(新散列表指针, 上一节点指针);
            }
            散列表_不扩容插入节点(新散列表指针, 当前节点指针);
        }
    }
    // 处理完备，返回新散列表
    return 新散列表指针;
}
// 用于散列表扩容后的‘链表节点’重新插入，因此假定散列表‘不需要扩容’，且剩余空间充足
void 散列表_不扩容插入节点(散列表* 散列表指针, 散列表链表节点 * 待插入节点指针) {
    待插入节点指针->下一节点指针 = NULL; // 将 下一节点指针 置空，防止干扰
    // 计算 键 散列值
    uint32_t 键散列值 = unicode切片_计算散列值(&(待插入节点指针->键), 散列表指针->容量);
    // 检查对应 表项 索引是否为空
    if (散列表指针->节点指针数组[键散列值] == NULL) { //该键不存在，插入链表第一个节点
        散列表指针->节点指针数组[键散列值] = 待插入节点指针;
    } else { //发生 散列冲突，向单向链表头部插入新节点
        待插入节点指针->下一节点指针 = 散列表指针->节点指针数组[键散列值]; //待插入节点指向原头部节点
        散列表指针->节点指针数组[键散列值] = 待插入节点指针; //散列表项 指向待插入节点
    }
}