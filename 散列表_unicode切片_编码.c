#include "散列表_unicode切片_编码.h"

#define 容量表表项 28
static uint32_t 容量质数表[容量表表项] = { //采用小于 2^n 的最大质数，构成容量质数表
    31, 61, 127,
    251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521,
    131071, 262139, 524287, 1048573, 2097143, 4194301, 8388593, 16777213,
    33554393, 67108859, 134217689, 268435399, 536870909, 1073741789, 2147483647, 4294967291
};

// 内部函数
散列表链表节点 * 创建散列表链表节点(unicode切片 键, 单词类型 值);
void           散列表_节点链表_释放(散列表链表节点* 首节点指针);
void 散列表_不扩容插入节点(散列表* 散列表指针, 散列表链表节点 * 待插入节点指针);
/******************************************************************************
 * 创建一个 空散列表 ，初始化后返回 散列表结构体的指针
 * 期望容量：期望的最小容量，如果为0则使用容量表最小容量
 *****************************************************************************/
散列表 * 创建散列表(uint32_t 期望容量) {
    // 查找容量质数表，确定新散列表容量
    int 实际容量;
    int i=0; // 从头到尾遍历容量表，直到找到足够容纳“期望容量”的最小容量表质数
    while (容量质数表[i] < 期望容量) {
        i++;
    }
    实际容量 = 容量质数表[i];
    // 申请堆内存 散列表对象
    散列表* 散列表指针 = (散列表*)malloc(sizeof(散列表)+实际容量*sizeof(散列表链表节点*));
    // 初始化散列表
    散列表指针->用量 = 0;
    散列表指针->容量 = 实际容量;
    for (int i=0; i<实际容量; i++) {// 初始化 数据区，节点指针数组全部置为 空 NULL
        散列表指针->节点指针数组[i] = NULL;
    }
    return 散列表指针;
}
// 创建 散列表链表节点
散列表链表节点 * 创建散列表链表节点(unicode切片 键, 单词类型 值) {
    // 构造新节点
    散列表链表节点 * 新节点指针 = (散列表链表节点*)malloc(sizeof(散列表链表节点));
    新节点指针->键 = 键; //初始化数据域
    新节点指针->值 = 值;
    新节点指针->下一节点指针 = NULL;
    return 新节点指针;
}
/******************************************************************************
 * 释放整个散列表，包括节点数组和链表节点，以及节点下游相关数据区
 * 散列表指针：被释放的 散列表结构体的指针
 *****************************************************************************/
void 散列表_释放(散列表* 散列表指针) {
    // 遍历 节点指针数组，逐个释放链表
    for (int i=0; i<(散列表指针->容量); i++) {
        if (散列表指针->节点指针数组[i] != NULL) { //数组中的节点指针不为空，就释放
            散列表_节点链表_释放(散列表指针->节点指针数组[i]);
        }
    }
    free(散列表指针); // 释放 散列表结构体
}
// 提供指向首节点的指针，释放整个单向链表的所有节点
void 散列表_节点链表_释放(散列表链表节点* 首节点指针) {
    散列表链表节点* 当前节点指针=首节点指针;
    散列表链表节点* 上一节点指针;
    // 遍历单向链表，释放上一节点
    while (当前节点指针->下一节点指针 != NULL) {
        上一节点指针 = 当前节点指针;
        当前节点指针 = 当前节点指针->下一节点指针;
        // 释放上一节点
        unicode切片_清空(&(上一节点指针->键)); // 先清空 切片 数据区
        free(上一节点指针); //再释放节点
    }
    // 释放尾节点
    unicode切片_清空(&(当前节点指针->键)); // 先清空 切片 数据区
    free(当前节点指针);
} 
/******************************************************************************
 * 插入一个 键-值 对
 * 键: 映射的 键
 * 值：映射 值
 *****************************************************************************/
void 散列表_插入(散列表* 散列表指针, unicode切片 键, 单词类型 值) {
    // 检查扩容，大于最大装载因子触发扩容
    if ((float)((散列表指针->用量)+1)/(散列表指针->容量) >= 散列表_最大装载因子) {
        散列表_扩容(散列表指针, 0);
    }
    // 构建 键-值 对节点
    散列表链表节点 * 新节点指针 = 创建散列表链表节点(键, 值);
    // 查询并插入新节点
    uint32_t 键散列值 = unicode切片_计算散列值(&键, 散列表指针->容量);
    if (散列表指针->节点指针数组[键散列值] == NULL) { //如果该 键 不存在
        散列表指针->节点指针数组[键散列值] = 新节点指针;
    } else { //发生 散列碰撞，向链表头部插入新节点
        新节点指针->下一节点指针 = 散列表指针->节点指针数组[键散列值];
        散列表指针->节点指针数组[键散列值] = 新节点指针;
    }
}
/******************************************************************************
 * 删除一个 键-值 对，如果 键 没有对应值则失败并返回-1
 * 键: 需要删除的 键
 *****************************************************************************/
int 散列表_删除(散列表* 散列表指针, unicode切片 键) { // 暂时不自动缩容
    // 计算散列值
    uint32_t 键散列值 = unicode切片_计算散列值(&键, 散列表指针->容量);
    // 查找 目标节点
    散列表链表节点 * 目标节点指针;
    if (散列表指针->节点指针数组[键散列值] == NULL) { 
        //无散列值，直接失败
        return -1;
    } else { 
        //有散列值，在链表中进一步查找
        散列表链表节点 * 当前节点指针;
        散列表链表节点 * 上一节点指针;
        当前节点指针 = 散列表指针->节点指针数组[键散列值]; //逐个查找链表节点
        while(当前节点指针->下一节点指针 != NULL){
            上一节点指针 = 当前节点指针; 
            当前节点指针 = 当前节点指针->下一节点指针;
            if (unicode切片_判等(&(上一节点指针->键), 键)) { //比对 上一节点
                //查询成功，跳出循环
                目标节点指针 = 上一节点指针;
                break;
            }
        }
        if (unicode切片_判等(&(当前节点指针->键), 键)) { //比对 当前节点 尾节点
                目标节点指针 = 上一节点指针; //查询成功，返回对应值
        } else { // 尾节点也比对失败，查询失败
            return -1;
        }
    }
    // 释放目标节点
    散列表链表节点_释放(目标节点指针);
}
// 释放拉链链表指定节点
void 散列表链表节点_释放(散列表链表节点 * 待释放节点) {
    // 先释放 切片 下游 堆数组
    unicode切片_清空(待释放节点);
    // 再释放 键值对节点
    free(待释放节点);
}
/******************************************************************************
 * 查询一个“键”，返回对应的“值”。如果失败返回 -1
 * 散列表指针：目标散列表结构体的指针
 * 键：查询的 键
 *****************************************************************************/
int 散列表_查询(散列表* 散列表指针, unicode切片 键) {
    // 计算散列值
    uint32_t 键散列值 = unicode切片_计算散列值(&键, 散列表指针->容量);
    // 查找 键
    if (散列表指针->节点指针数组[键散列值] == NULL) { 
        //无散列值，直接失败
        return -1;
    } else { 
        //有散列值，在链表中进一步查找
        散列表链表节点 * 当前节点指针;
        散列表链表节点 * 上一节点指针;
        当前节点指针 = 散列表指针->节点指针数组[键散列值]; //逐个查找链表节点
        while(当前节点指针->下一节点指针 != NULL){
            上一节点指针 = 当前节点指针; 
            当前节点指针 = 当前节点指针->下一节点指针;
            if (unicode切片_判等(&(上一节点指针->键), 键)) { //比对 上一节点
                return 上一节点指针->值; //查询成功，返回对应值
            }
        }
        if (unicode切片_判等(&(当前节点指针->键), 键)) { //比对 当前节点 尾节点
                return 当前节点指针->值; //查询成功，返回对应值
        } else { // 尾节点也比对失败，查询失败
            return -1;
        }
    }
}
/******************************************************************************
 * 扩容散列表到至少可以容纳 期望容量
 * 期望容量：期望容量表扩容后的最小容量。如果为0则自动扩容到容量表下一容量
 *****************************************************************************/
void 散列表_扩容(散列表* 旧散列表指针, uint32_t 期望容量) {
    // 查找容量质数表，确定 新散列表 容量
    int 新容量;
    if (期望容量 == 0) { 期望容量 = 旧散列表指针->容量 + 1; } //如果为0，则自动扩容到容量表下一项
    int i=0; // 从头到尾遍历容量表，直到找到足够容纳“期望容量”的最小质数
    while (容量质数表[i] < 期望容量) {
        i++;
    }
    新容量 = 容量质数表[i];
    // 申请 新散列表 空间，并初始化 新散列表
    散列表 * 新散列表指针 = malloc(sizeof(散列表)+新容量*sizeof(散列表链表节点*));
    新散列表指针->容量 = 新容量;
    新散列表指针->用量 = 旧散列表指针->用量;
    for (int i=0; i<容量质数表[0]; i++) {// 初始化 数据区，节点指针数组全部置为 空 NULL
        新散列表指针->节点指针数组[i] = NULL;
    }
    // 遍历旧散列表节点，将各节点填入 新散列表
    散列表链表节点 * 当前节点指针;
    散列表链表节点 * 上一节点指针;
    for (int i=0; i<旧散列表指针->用量; i++) {
        if (旧散列表指针->节点指针数组[i] != NULL) { //处理非空表项
            // 遍历单向链表，将其插入新散列表
            当前节点指针 = 旧散列表指针->节点指针数组[i];
            while(当前节点指针->下一节点指针 != NULL){
                上一节点指针 = 当前节点指针;
                当前节点指针 = 当前节点指针->下一节点指针;
                散列表_不扩容插入节点(新散列表指针, 上一节点指针);
            }
            散列表_不扩容插入节点(新散列表指针, 当前节点指针);
        }
    }
    // 释放 旧散列表
    free(旧散列表指针);
    // 处理完备，返回新散列表
    return 新散列表指针;
}
// 用于散列表变容后的‘链表节点’重新插入，因此假定散列表剩余空间充足，‘不需要扩容’
void 散列表_不扩容插入节点(散列表* 散列表指针, 散列表链表节点 * 待插入节点指针) {
    待插入节点指针->下一节点指针 = NULL; // 将 下一节点指针 置空，防止干扰
    // 计算 键 散列值
    uint32_t 键散列值 = unicode切片_计算散列值(&(待插入节点指针->键), 散列表指针->容量);
    // 检查对应 表项 索引是否为空
    if (散列表指针->节点指针数组[键散列值] == NULL) { //该键不存在，插入链表第一个节点
        散列表指针->节点指针数组[键散列值] = 待插入节点指针;
    } else { //发生 散列冲突，向单向链表头部插入新节点
        待插入节点指针->下一节点指针 = 散列表指针->节点指针数组[键散列值]; //待插入节点指向原头部节点
        散列表指针->节点指针数组[键散列值] = 待插入节点指针; //散列表项 指向待插入节点
    }
}